* Comprimir la cantidad de jugadores y el tipo de paquete
* Probar si el servidor aplica los inputs mas de una vez si le llegan repetidos. //DONE
* Refactorear los inputs para que se identifiquen y si me llegan viejos no los aplique constantemente. //Done
* Una clase por arriba que todo el tiempo absorve los paquetes y mandando los ack y arriba de eso el tiene la clase del server que utiliza los inputs para procesar.
* Podemos asignar siempre el de la prediccion si queremos, en vez de la comparacion.
A considerar capaz conviene.
* La prediccion moverla en el FixedUpdate
* El inicializar al jugador en todo el lugar posible evitando adentro del cuadrado que no se puede.
* Chequear que un mismo cliente no se conecte mas de una vez
* Mirar el sequence si es incremental por cliente o uno por cada worldInfo y despues mirar como se usa del lado del cliente
* Hacer que no se pueda conectar varias veces un mismo cliente(guardar los endpoints de los clientes)

Animaciones
* De los otros personajes la animacion es parte del estado, entonces lo que hay que hacer es que en el snapshot se envie el estado del jugador, para la animacion
* Cuando abris el animator a la izquierda esta layers y parameters, podes crear un boolean agachado, corriendo, etc Le llevas una flechita de anyState a agachado
cuando agachado sea true.

* Agregar lo de la animacion de que se muere un enemigo y eliminar el game objext tanto server como cliente
* Decidir que hacer cuando matan al jugador.

----------------------------------------------------------------------------------------------------------------------

* Capaz hacer que el server envie tal jugador disparo a tal confiable.

* Comandos para correr app en mac:
       - xattr -cr pathToApp.app
       - chmod -R +x pathToApp/Contents/MacOs
       
* Agregar animacion enemigo
* Agregar los prefabs en clientManager y en ServerManager //DONE
* Agregar la vida //DONE
* Agregar menu de pausa
* Agregar muerte del jugador y play again
* Agregar latencia, entre 0 y 0.5 seg con el boton L podria ser y R para volver a 0
* Fixear el line rendering
* Hacer la pantalla de damage. //DONE 
* Refactorear codigo y estructura del proyecto
* Hacer un README con lo que hace cada clase
* Probar distintos PPS